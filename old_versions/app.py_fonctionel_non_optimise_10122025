import io
import time
import requests
import pandas as pd
import streamlit as st
from PIL import Image
from openpyxl.utils import get_column_letter
from openpyxl.drawing.image import Image as XLImage

# ==========================
# CONFIG GLOBALE
# ==========================

# Colonnes de sortie pour les URLs d'images
IMAGE_COLS = ["image_url_1", "image_url_2", "image_url_3"]

# Endpoint SerpAPI
SERPAPI_ENDPOINT = "https://serpapi.com/search.json"


# ==========================
# FONCTIONS M√âTIER
# ==========================

def build_query(row: pd.Series, search_columns):
    """
    Construit la requ√™te de recherche en respectant l'ordre choisi par l'utilisateur.
    search_columns est une liste ordonn√©e de noms de colonnes.
    """
    parts = []
    for col in search_columns:
        value = row.get(col)
        if pd.notna(value):
            text = str(value).strip()
            if text:
                parts.append(text)
    return " ".join(parts)


def search_images_serpapi(query: str, serpapi_key: str, max_results: int = 3):
    """
    Interroge SerpAPI (Google Images) et retourne une liste d'URLs d'images.
    """
    params = {
        "engine": "google_images",  # ou "bing_images" si tu pr√©f√®res
        "q": query,
        "num": max_results,
        "api_key": serpapi_key,
    }

    response = requests.get(SERPAPI_ENDPOINT, params=params, timeout=30)
    response.raise_for_status()
    data = response.json()

    results = data.get("images_results", [])
    urls = []
    for r in results:
        # "original" est g√©n√©ralement l'URL de l'image en taille normale
        url = r.get("original") or r.get("thumbnail")
        if url:
            urls.append(url)
        if len(urls) >= max_results:
            break

    return urls


def enrich_df_with_images(
    df: pd.DataFrame,
    serpapi_key: str,
    search_columns,
    max_images: int = 3,
    sleep_seconds: float = 0.2,
):
    """
    Enrichit un DataFrame avec des URLs d'images.
    Ajoute les colonnes IMAGE_COLS si elles n'existent pas.
    Utilise les colonnes search_columns dans l'ordre fourni.
    """
    if not search_columns:
        st.error("Aucune colonne s√©lectionn√©e pour la recherche d'images.")
        return df

    # S'assurer que les colonnes de sortie existent
    for i, col in enumerate(IMAGE_COLS[:max_images]):
        if col not in df.columns:
            df[col] = None

    progress_bar = st.progress(0)
    status_text = st.empty()
    total = len(df)

    for idx, (row_index, row) in enumerate(df.iterrows(), start=1):
        query = build_query(row, search_columns)

        if not query.strip():
            status_text.text(f"Ligne {row_index}: requ√™te vide, ignor√©e.")
        else:
            try:
                urls = search_images_serpapi(
                    query=query,
                    serpapi_key=serpapi_key,
                    max_results=max_images,
                )
                for i, url in enumerate(urls):
                    df.at[row_index, IMAGE_COLS[i]] = url

                status_text.text(
                    f"Ligne {row_index}: {len(urls)} image(s) trouv√©e(s) pour '{query[:60]}...'"
                )
            except Exception as e:
                status_text.text(f"Ligne {row_index}: ERREUR ({e})")

            time.sleep(sleep_seconds)

        progress_bar.progress(idx / total)

    status_text.text("Recherche d'images termin√©e ‚úÖ")
    return df


def create_excel_with_embedded_images(
    df: pd.DataFrame,
    image_cols,
    jpg_quality: int = 80,
    image_width: int = 80,
    image_height: int = 80,
):
    """
    Cr√©e un fichier Excel en m√©moire avec :
    - les donn√©es du DataFrame,
    - les images t√©l√©charg√©es, converties en JPG,
      ins√©r√©es dans les cellules correspondant aux colonnes image_cols.
    """
    output = io.BytesIO()

    with pd.ExcelWriter(output, engine="openpyxl") as writer:
        df.to_excel(writer, index=False, sheet_name="Produits")
        wb = writer.book
        ws = wb["Produits"]

        for row_idx, row in df.iterrows():
            excel_row = row_idx + 2  # 1 = header, 2 = premi√®re ligne de donn√©es

            for img_col in image_cols:
                if img_col not in df.columns:
                    continue

                url = row.get(img_col)
                if not isinstance(url, str) or not url.strip():
                    continue

                try:
                    resp = requests.get(url, timeout=30)
                    resp.raise_for_status()

                    pil_img = Image.open(io.BytesIO(resp.content))
                    if pil_img.mode != "RGB":
                        pil_img = pil_img.convert("RGB")

                    img_bytes = io.BytesIO()
                    pil_img.save(
                        img_bytes,
                        format="JPEG",
                        quality=jpg_quality,
                        optimize=True,
                    )
                    img_bytes.seek(0)

                    xl_img = XLImage(img_bytes)
                    xl_img.width = image_width
                    xl_img.height = image_height

                    col_idx = df.columns.get_loc(img_col) + 1
                    col_letter = get_column_letter(col_idx)
                    cell_ref = f"{col_letter}{excel_row}"

                    ws.add_image(xl_img, cell_ref)

                except Exception:
                    # On ignore les erreurs individuelles pour ne pas bloquer tout le process
                    continue

    output.seek(0)
    return output


# ==========================
# INTERFACE STREAMLIT
# ==========================

def main():
    st.set_page_config(page_title="Catalogue produit avec images (SerpAPI)", layout="wide")

    st.title("üß† Catalogue produit avec images (SerpAPI + Excel avec images int√©gr√©es)")

    st.header("1. Cl√© SerpAPI (Google Images)")
    serpapi_key = st.text_input(
        "Cl√© API SerpAPI",
        type="password",
        help="Cr√©e une cl√© sur https://serpapi.com/ puis colle-la ici.",
    )

    max_images = st.slider(
        "Nombre d'images par produit",
        min_value=1,
        max_value=len(IMAGE_COLS),
        value=3,
        step=1,
    )

    sleep_seconds = st.slider(
        "Pause entre chaque requ√™te (secondes)",
        min_value=0.0,
        max_value=1.0,
        value=0.2,
        step=0.1,
        help="Permet de lisser les appels √† l'API si tu as beaucoup de lignes.",
    )

    st.header("2. Upload du fichier Excel")
    uploaded_file = st.file_uploader(
        "Choisis ton fichier Excel (.xlsx)",
        type=["xlsx"],
    )

    if uploaded_file is None:
        st.info("‚û°Ô∏è Uploade un fichier Excel pour commencer.")
        return

    try:
        df = pd.read_excel(uploaded_file)
    except Exception as e:
        st.error(f"Erreur de lecture du fichier Excel : {e}")
        return

    st.success("Fichier bien re√ßu ‚úÖ")
    st.subheader("Aper√ßu des premi√®res lignes")
    st.dataframe(df.head())

    st.header("3. Colonnes √† utiliser pour la requ√™te (ordre de priorit√©)")

    columns = list(df.columns)
    candidate_keywords = [
        "ean", "gtin", "ref", "code", "sku",
        "nom", "name", "brand", "marque", "description"
    ]
    default_cols = [
        col for col in columns
        if any(kw in col.lower() for kw in candidate_keywords)
    ][:4]

    search_columns = st.multiselect(
        "Colonnes utilis√©es pour construire la requ√™te (dans l'ordre) :",
        options=columns,
        default=default_cols,
        help="L'ordre compte : ex. [marque, nom, EAN, description].",
    )

    st.header("4. Param√®tres d‚Äôinsertion des images dans Excel")

    jpg_quality = st.slider(
        "Qualit√© JPG (1 = tr√®s compress√©, 95 = haute qualit√©)",
        min_value=30,
        max_value=95,
        value=80,
        step=1,
        help="Compromis entre taille de fichier et qualit√© visuelle."
    )

    image_width = st.slider(
        "Largeur des images (px)",
        min_value=40,
        max_value=200,
        value=80,
        step=5,
    )

    image_height = st.slider(
        "Hauteur des images (px)",
        min_value=40,
        max_value=200,
        value=80,
        step=5,
    )

    st.header("5. Lancer le traitement")

    if not serpapi_key:
        st.info("‚û°Ô∏è Renseigne ta cl√© SerpAPI pour activer le bouton.")
        return

    if not search_columns:
        st.info("‚û°Ô∏è S√©lectionne au moins une colonne de recherche.")
        return

    if st.button("üîç Enrichir avec des images et les ins√©rer dans l'Excel"):
        with st.spinner("Traitement en cours..."):
            # 1) Recherche d'images (URLs)
            df_enriched = enrich_df_with_images(
                df.copy(),
                serpapi_key=serpapi_key,
                search_columns=search_columns,
                max_images=max_images,
                sleep_seconds=sleep_seconds,
            )

            # 2) Cr√©ation du fichier Excel avec images int√©gr√©es
            excel_buffer = create_excel_with_embedded_images(
                df_enriched,
                image_cols=IMAGE_COLS[:max_images],
                jpg_quality=jpg_quality,
                image_width=image_width,
                image_height=image_height,
            )

        st.subheader("Aper√ßu des donn√©es enrichies (URLs d'images)")
        st.dataframe(df_enriched.head())

        st.download_button(
            label="‚¨áÔ∏è T√©l√©charger le fichier Excel avec images int√©gr√©es",
            data=excel_buffer,
            file_name="produits_avec_images_integrees.xlsx",
            mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        )


if __name__ == "__main__":
    main()

